summary: Погружение в KMM в IceRock №1
id: kmm-icerock-onboarding-1
categories: russian,kmm-icerock-onboarding,moko
status: published
authors: Andrey Kovalev, Aleksey Lobynya, Aleksey Mikhailov
tags: onboarding,kmm,ios,android,moko
feedback link: https://github.com/icerockdev/kmp-codelabs/issues

### Вводная часть

Привет! Если ты это читаешь, значит ты начинаешь погружаться в процессы мультиплатформенной разработки в IceRock. 

Мы активно применяем и продвигаем этот подход с 2017-2018 годов. Основная его ценность для нас - это возможность объединения бизнес-логики приложения в одном месте для обеих платформ. Вместо того, чтобы отлаживать и реализовывать логику отдельно для iOS и Android мы пишем общий код, который используют обе платформы. Один и тот же код. Соответственно, баги, связанные с некорректной логикой, не будут плавать с платформы на платформу. И не потребуется отвлекать разных разработчиков - проблемы в логике могут быть исправлены одним человеком, в одном месте и починить сразу и iOS, и Android. Круто же)

При этом взаимодействие с пользователем остаётся 100% нативным. Доступен полный набор всех средств, которые предоставляют нативные SDK. Юзер использует привычные элементы и приложение ведёт себя так, как привыкли пользователи каждой платформы.

Обратная сторона медали - сложности на первых порах, при вхождении в такой подход и метод разработки. Для андроид-разработчиков особо ничего не меняется - они могут использовать всё тот же Kotlin, модульность, Gradle, корутины и прочие незнакомые большинству iOS-ников вещи.
А iOS-разработчик, в свою очередь, попадая впервые на мультиплатформенный проект, едет кукухой от того, что в проект подцепляется какой-то мультиплатформенный под-чёрный-ящик, в котором какая-то куча вьюмоделей, реализующих внутри магию с логикой, кругом какие-то диспатчеры, юниты, экран со сложной вёрсткой в контроллере состоит из таблицы и нескольких строчек биндинга,не понятно откуда что берётся и вопросов больше, чем ответов.

На самом же деле всё довольно просто и логично. Сгруппировано, разбито и структурировано. Но вникнуть в эту концепцию придя на уже живущий проект, находящийся в активной разработке сложно из-за большого объёма информации и логики.

Поэтому данный гайд призван помочь пройтись по шагам по основным практически моментам, ежедневно встречающимся в нашей повседневной разработке. В нём ты сможешь по очереди выполнять задания, наращивать функционал тестового проекта и изучать устройство проекта изнутри.

Здесь не будет детального разбора теоретической части, т.к. по ней уже имеется большое количество статей и документации, к которым можно обращаться в процессе. Вставить ссылку на страницу с доками Здесь ты именно закрепляешь на практике теоретические знания из статей. Так что наливай чаёк-кофеёк и поехали)


### Подготовительные шаги

В рамках адаптации ты уже должен был развернуть себе рабочее окружение, поэтому тут не заостряемся на этом. Глянуть детальнее можно здесь: [https://kmm.icerock.dev/pages/2-setup/](https://kmm.icerock.dev/pages/2-setup/)

Основные два рабочих инструмента - Android Studio и Xcode.

В качестве отправной точки мы будем использовать наш шаблоный проект - **mobile-moko-boilerplate**. Он используется на всех новых проектах для быстрого развёртывания и старта разработки. Там уже подключены все минимально необходимые зависимости, имеется нужная структура папок и базовая настройка проекта. Так что заходим на GitLab в репозиторий [https://gitlab.icerockdev.com/scl/boilerplate/mobile-moko-boilerplate](https://gitlab.icerockdev.com/scl/boilerplate/mobile-moko-boilerplate) и делаем форк себе в профиль, клонируем.

Для начала откроем в его Android Studio.

Запускаем студию, File -> Open -> И выбираем папку, в которую склонировали репозиторий. При первом открытии должно появиться следующее:


По-умолчанию студия парсит каталоги и строит отображение как для Android-проекта. Но мы здесь будем работать не только с андроидом, но и с мультиплатформой. 

Поэтому переключаем отображение. Для этого слева нажимаем на выпадашку Android и выбираем вместо него Project:


После этого структура папок немного изменится:



Далее соберём iOS проект. Как именно это сделать можно прочитать тут же в Readme открытого проекта. Но чтобы было нагляднее - пройдём эти незамысловатые шаги для ios-проекта.

Сначала ставим поды.


После этого справа разворачиваем панель Gradle. Внутри Tasks/cocoapods находим нужную нам таску(ниже скрин):

syncMultiPlatformLibraryDebugFrameworkIosX64

и запускаем её двойным кликом. Тут придётся немного подождать. А чтобы лучше понять, что сейчас произошло, как эти таски появились и что это за Gradle и слон со стрелкой - идём читать статейку про Gradle для айосников тут: 

[https://kmm.icerock.dev/pages/4.1.1-kmm-ios-gradle/](https://kmm.icerock.dev/pages/4.1.1-kmm-ios-gradle/)

После успешного завершения билда необходимо ещё раз выполнить установку подов. И далее можно запускать Xcode и открывать проект, который лежит по пути ios-app/ios-app.xcworkspace

Выбираем любой симулятор, жмём Run - проект собирается и запускается.

И это успех) Мы выкачали и собрали мультиплатформенный проект с нуля. Аналогичным образом происходит работа со всеми другими MPP-проектами в компании. Поэтому когда ты попадёшь на боевой проект, то уже точно будешь знать, как его выкачать из репозитория, собрать и запустить у себя. Наиболее частая причина ошибок на этом шаге - неправильная последовательность действий. Если вдруг что-то пошло не так, то проверь, что ты установил поды, выполнил синк, а после этого снова установил поды. 

А мы переходим к следующей части и разберёмся, как работать с этим дальше.


### Построение навигации в iOS приложении

Прежде чем идти дальше немного остановимся на том, как построена навигация в iOS приложение и какие подходы при работе с ней мы используем.

В основе навигации лежат координаторы. Каждый координатор покрывает логически связанный блок функционала, который чаще всего состоит из нескольких экранов. При этом между собой они независимы и отвечают только за цепочку переходов только внутри себя. Также имеют возможность получать настройку действия, которое должно быть выполнено после завершения блока ответственности координатора.

Например.

Предположим, что у нас есть приложение, в котором имеется авторизация, просмотр списка новостей, с возможностью перехода к детальному виду каждой новости, а со списка новостей можно попасть в раздел настроек для конфигурации отображения новостей. Это разобьётся на 4 координатора:



1. AppCoordinator
    1. Стартовый координатор. Всегда является первой входной точкой, определяет, куда должен выполниться дальнейший переход при запуске приложения
    2. Если юзер не авторизован - запустит координатор авторизации и в качестве completionHandler-а укажет ему переход на новости в случае успешной авторизации
    3. Если юзер уже авторизован - запустит координатор просмотра новостей
2. AuthCoordinator
    4. Запустит процесс авторизации
    5. Будет совершать переходы по всем требуемым шагам - например ввод логина/пароля, смс-кода, установки никнейма и т.п.
    6. По итогу успешной авторизации вызовет переданный ему на вход completionHandler.
3. NewsCoordinator
    7. Отвечает за показ списка новостей
    8. Реализовывает переход в детали конкретной новости внутри этого же координатора
    9. При переходе в настройки создаёт координатор настроек, с качестве completionHandler-а может передать ему логику обновления своего списка новостей. Если в настройках изменились параметры - обновляет список
4. SettingsCoordinator
    10. Отвечает за работу с экраном настроек
    11. При завершении работы и применении настроек вызывает completion, чтобы новости обновились

Именно координаторы реализуют интерфейс EventListener-ов вьюмоделей, о которых будет чуть ниже. Так как вызов переходов завязан на бизнес-логику приложения, то инициатором этих переходов являются именно вьюмодели. Поэтому координаторы выполняют связующую роль между тем, что происходит в логике приложений и тем, как это должно отражаться пользователю.

Чтобы работать с координаторами было проще, используется базовый класс, от которого наследуются остальные. Добавим его к нашему проекту.

Создадим в ios-проекте папку src/Coordinators и в ней файлик BaseCoordinator. Для начала докинем туда пару протоколов:

```swift

protocol ChildCoordinable {

    var childCoordinators: [Coordinator] { get set }

    func addDependency(_ coordinator: Coordinator)

    func removeDependency(_ coordinator: Coordinator?)

}
```

ChildCoordinable - необходим для корректной работы с зависимостями от дочерних координаторов. Необходимо не забывать добавлять зависимости на новый координаторы, очищать зависимость на конкретный координатор и запоминать список тех координаторов, которые являются дочерними к текущему.

```swift
protocol Coordinator: class {

    var completionHandler: (() -> Void)? { get set }

    

    func start()

}
```

Coordinator - сам протокол координатора. По сути он должен иметь ровно две вещи - completionHandler, который вызовется при завершении его логической зоны ответственности. И функцию start. При её вызове он начинает запускать свой флоу таким образом, каким считает нужным.

И далее сам класс базового координатора, который реализует оба этих протокола:

```swift

class BaseCoordinator: NSObject, Coordinator, ChildCoordinable, UINavigationControllerDelegate {

    var childCoordinators: [Coordinator] = []

    var completionHandler: (() -> Void)?

    

    let window: UIWindow

    

    weak var navigationController: UINavigationController?

    

    init(window: UIWindow) {

        self.window = window

    }

    

    func start() {

        

    }

    

    func addDependency(_ coordinator: Coordinator) {

        for element in childCoordinators where element === coordinator {

            return

        }

        childCoordinators.append(coordinator)

    }

    

    func removeDependency(_ coordinator: Coordinator?) {

        guard

            childCoordinators.isEmpty == false,

            let coordinator = coordinator

        else { return }

        

        for (index, element) in childCoordinators.enumerated() where element === coordinator {

            

            childCoordinators.remove(at: index)

            break

            

        }

    }

    

    func currentViewController() -> UIViewController? {

        return self.navigationController?.topViewController?.presentedViewController ?? self.navigationController?.topViewController ?? self.navigationController

    }

    

    func popBack() {

        self.navigationController?.popViewController(animated: true)

    }

}
```



Для инициализации необходим только window. Также можно указать NavigationController с предыдущего координатора, для сохранения общей навигации.

Добавление и удаление зависимостей нужны для корректной очистки связей и памяти при построении цепочек координаторов.

Также есть вспомогательные методы, которые позволяют получить текущий контроллер - currentViewController и совершить переход назад - popBack.

От проекта к проекту базовый координатор может изменяться, обеспечивая дополнительные нужды проекта.

Теперь, когда у нас есть базовый координатор, создадим на его основе стартовый координатор приложения. Создаём рядом с AppDelegate файл для него, называем AppCoordinator:

```swift

import Foundation

import UIKit

class AppCoordinator: BaseCoordinator {

    // MARK:** - Overrides**

    override func start() {

        let vc = UIViewController()

        vc.view.backgroundColor = UIColor.green

        self.window.rootViewController = vc

    }

}
```

Пусть он пока будет совсем простой, создающий контроллер зелёного цвета и делает его главным экраном window.

Теперь нам надо познакомить AddDelegate с его координатором. Идём в AppDelegate.swift

Добавим ему ссылку на координатор приложения:

private (set) var coordinator: AppCoordinator!

А в didFinishLaunchingWithOptions после создания SharedFactory добавим создание координатора и вызов старта:

```swift

self.coordinator = AppCoordinator(

            window: self.window!

        )

self.coordinator.start()
```

Готово. Собираем, запускаем и видим наш зелёный контроллер:

Теперь дальнейшая логика переходов зависит от текущего контроллера и действий юзера на нём. Но зелёным прямоугольником мир не спасёшь и юзера не авторизуешь. Поэтому пора переходить к созданию нашей первой фичи.


### Создаём нативную фичу

Как правило фичи в нативном проекте соответствуют аналогичным фичам в мультиплатформенном проекте. Мы начнём с простого - с авторизации. Если открыть в AndroidStudio проект и зайти в папку mpp-library, то мы увидим в ней папку features - это и есть наши фичи. В ней уже даже есть auth. Сделаем для неё нативную реализацию.

Сначала наметим структуру папок в нашем проекте. Внутри src создадим папку Features, а в ней - Auth. Для авторизации нам понадобится контроллер и координатор. Чтобы всё не смешивалось в кучу (а в боевых проектах в фиче сильно больше файлов будет) сразу научимся группировать по папкам содержимое фичи. Заведём директории под контроллеры, координаторы и сами классы. Получится следующая структура:


Вёрстку мы ведём через xib-файлы. Обработчики действий и связи настраиваются через IBActions и IBOutlets. Кастомизация UI-элементов стилями конкретного проекта уже происходит кодом. Здесь мы не будем уходить глубоко в кастомизацию, поэтому контроллер у нас будет довольно простой - лейбл, пара полей для ввода логина и пароля и кнопка входа.

На вкус и цвет фломастеры бывают разные, можешь отверстать экран по-своему. Основные требования - Label-заголовок, два UITextField и одна кнопка UIButton. Что-то типа такого:

И класс у неё также пока очень простой:

```swift

import UIKit

class AuthViewController: UIViewController {

    // MARK:** - Outlets**

    @IBOutlet private var welcomeLabel: UILabel!

    @IBOutlet private var loginTextField: UITextField!

    @IBOutlet private var passwordTextField: UITextField!

    @IBOutlet private var loginButton: UIButton!

    

    // MARK:** - Actions**

    

    @IBAction func onLoginButtonAction(_ sender: UIButton) {

        // On button Action

    }

}

Далее создадим координатор:

class AuthCoordinator: BaseCoordinator {

    // MARK:** - Overrides**

    override func start() {

        let vc = AuthViewController()

        self.window.rootViewController = vc

    }

}
```

Он также несложный. Состоит пока из одного метода start, который помещает на window наш созданный AuthViewController.

И чтобы это всё работало изменяем координатор приложения. Теперь нам там нужно убрать тот тестовый зелёный экран и запустить флоу координатора авторизации:

```swift

class AppCoordinator: BaseCoordinator {

    // MARK:** - Overrides**

    override func start() {

        routeToAuth()

    }

    

    private func routeToAuth() {

        

        // 1. Создаём координатор авторизации

        

        let authCoordinator = AuthCoordinator(window: self.window)

        

        // 2. Обязательно указываем в completionHandler удаление зависимости.

        // Также добавляем сразу заготовку под будущий переход к новостям при успешной авторизации

        authCoordinator.completionHandler = { [weak self] in

            self?.removeDependency(authCoordinator)

            self?.routeToNewsList()

        }

        

        // 3. Добавляем новый координатор в зависимость к текущему

        addDependency(authCoordinator)

        

        // 4. Вызываем у него старт

        authCoordinator.start()

    }

    private func routeToNewsList() {

        // Здесь будет переход к новостям

    }

}

```

Собираем, запускаем и видим уже не тот недохромакей, а контроллер авторизации, который только что сверстали. Комментариями к коду подписаны основные шаги в создании нового координатора. Важным моментом является удаление зависимости в completion-блоке создаваемого координатора, чтобы не плодились утечки памяти.

Также полезно будет указать сразу заглушку для метода перехода к новостям. Пусть он пока и пустой, зато сразу получаем более общую картину, где какие вызовы будут в будущем.

Окей. Мы создали контроллер, создали координатор. Даже перешли на экран авторизации. Но как будет реализовываться логика? Где брать вьюмодель? Как она узнает, что юзер что-то ввёл? Как координатор поймёт, что ему нужно вызывать completion и переходить к новостям, ведь контроллер, который мы создали, даже не знает о том, что какой-то там координатор существует?

Чтобы понять, как это работает перейдём к созданию вьюмодели и передаче её контроллеру.


### Дружим ViewController и ViewModel

// Описать создание VM через фабрику, добавить базовый MVVM контроллер, допилить AuthController, сделать пустой биндинг и перейти к описанию


### 


### Принцип связи общей и нативной частей


// Пояснить, что есть что и где находится в общих чертах, дальше перейти к деталям


### 


### Обработка действий пользователя и передача данных от натива к общей части

// Заводим филды во вьюмодели, публичный метод для обработчика кнопки с принтом в консоль, показываем, как биндиться к филдам, биндим доступность кнопки, биндим текст лейбла к лайвдате


### 


### Реализация логики и передача событий и команд от общей части к нативной

// Дополняем EventListener для VM авторизации, в ней роут на новости и showError

ПОКАЗАТЬ ЧТО СБОРКА ЛОМАЕТСЯ, объяснить, как влияют правки общие на соседнюю платформу. Замокать без репозитория на уровне VM проверку логина/пароля.




### Локализация и ресурсы

// Рассказать про моко-ресурсы, завести табличку, добавить строк, добавить интерфейс строк в VM, пробросить при реализации, изменить текста ошибок на StringDesc локализованный.


### Сохранение в локальное хранилище. 

// Добавить логику запоминания токена в локальном хранилище. Показать, как с сеттингсами работать. 


### 


### Построение экранов

// Раздел для описания разных подходов к вёрстке экранов


#### Нативная вёрстка

// Сослаться на авторизацию, объяснить про вёрстку на чистом нативе с биндингами


#### На основе юнитов

// Рассказать, что такое юниты, переходить к вёрстке списка новостей, создавать фабрику юнитов, описать, что стоит, а что не стоит кидать в них, когда нужны id, что такое диффабл датасурс, почему текстовые поля и юниты - не всегда супер хорошо


### Работа с сервером и запросами


#### Как генерируются API?

Показываем генерацию по спекам, куда попадают файлы


#### Как создать свою, если нужен запрос, а нет swagger?

Показываем, как создать свой Api-класс


#### Как вьюмодель ходит на сервер?

Рассказать про интерфейс репозитория, который есть у фичи. Создать его для авторизации, реализовать, добавить в создании доменной фабрики


#### Как правильно мокать, если не готов сервер?

Показать, как правильно мокать на уровне репозитория и почему предыдущее решение с моком на вьюмодели неоптимальное. Докинуть примеров.


#### 


### Обработка ошибок

// моко-еррорс
