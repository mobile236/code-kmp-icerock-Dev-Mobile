
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>MOKO Widgets #2 - routing</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="UA-81805223-5"
                  id="moko-widgets-2"
                  title="MOKO Widgets #2 - routing"
                  environment="web"
                  feedback-link="https://github.com/icerockdev/kmp-codelabs/issues">
    
      <google-codelab-step label="Вводная" duration="5">
        <p>Урок является продолжением <a href="https://codelabs.kmp.icerock.dev/codelabs/moko-widgets-1/" target="_blank">MOKO Widgets #1 - hello world</a>. Для выполнения данного урока нужно иметь проект, полученный в результате выполнения предыдущего урока.</p>
<p>Результатом прошлого урока был экран входа с полем ввода имени и кнопкой отправки:</p>
<table>
<tr></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img alt="android-app" src="img/9576e0146a71f98f.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="ios-app" src="img/35e157c9148e2dab.png"></p>
</td></tr>
</table>
<p>На этом уроке мы добавим навигацию между экранами. Схема переходов будет следующая:<br><img alt="navigation-scheme" src="img/639f7f0c1a0b8b90.jpg"><br>Будут разобраны переходы:</p>
<ul>
<li>Обычный переход вперед;</li>
<li>Переход назад;</li>
<li>Переход вперед с передачей данных;</li>
<li>Нижняя навигация табами;</li>
<li>Переход с обработкой возвращаемого результата.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Обновляем свой проект" duration="2">
        <p>В этом уроке потребуется обновленная версия moko-widgets, поэтому сначала требуется обновиться до версии <a href="https://github.com/icerockdev/moko-widgets/releases/tag/release%2F0.1.0-dev-7" target="_blank">0.1.0-dev-7</a>.<br>Изменения, которые нужно сделать можно посмотреть в <a href="https://github.com/icerockdev/moko-widgets-template/commit/a617b9bfc6e42fa4203253825d7e530fc496a4d2" target="_blank">коммите</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Схема авторизации" duration="2">
        <p>Согласно схеме экранов процесс авторизации состоит из 2 экранов, после чего переход выполняется на главную.<br><img alt="navigation-scheme" src="img/639f7f0c1a0b8b90.jpg"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Авторизация - экран ввода телефона" duration="30">
        <p>Переименуем полученный на прошлом уроке <code>LoginScreen</code> в <code>InputPhoneScreen</code> и перенесем в пакет <code>org.example.mpp.auth</code> - в нем соберем все классы относящиеся к авторизации, при чем сделаем это так, чтобы никаких внешних зависимостей у классов лежащих в этом пакете не было. Это позволит вынести эти классы в отдельный gradle модуль (разделение по фичам).</p>
<h2 is-upgraded>Реализация ViewModel</h2>
<p>Далее реализуем обработку действий пользователя, для этого заведем <code>InputPhoneViewModel</code>, в которой будет <code>phoneField</code> (ранее мы просто создавали инстанс поля не запоминая ссылку на него. Этот объект требуется для <code>input</code> виджета).</p>
<pre><code>class InputPhoneViewModel() : ViewModel() {

    val phoneField: FormField&lt;String, StringDesc&gt; = FormField(
        initialValue = &#34;&#34;,
        validation = liveBlock { null }
    )

    fun onSubmitPressed() {
        val phone = phoneField.data.value
        println(&#34;phone: $phone&#34;)
    }
}
</code></pre>
<p>Описанная выше <code>ViewModel</code> содержит в себе поле ввода телефона, с выключенной валидацией (блок <code>liveBlock { null}</code> означает ошибки всегда нет), а так же обработчик нажатия <code>onSubmitPressed</code>, который выведет введенный телефон в лог.</p>
<h2 is-upgraded>Привязка Screen к ViewModel</h2>
<p>Теперь нужно привязать экран к <code>InputPhoneViewModel</code>.</p>
<aside class="special"><p><code>ViewModel</code> переживает смену конфигурации на android. Это означает что если пользователь повернет экран или сменит язык в системе или включит разделение экрана, то данные, которые хранятся в <code>ViewModel</code>, а так же и все действия которые она выполняет, останутся доступны и новый пересозданный системой экран подключится к старой вьюмодели, без потерь данных. Чтобы эта логика работала нужно использовать функции получения <code>ViewModel</code> у <code>Screen</code>: <code>getViewModel {}</code> где в лямбде указывается как создать новую вьюмодель, если старой еще нет.</p>
</aside>
<pre><code>class InputPhoneScreen(
    ...
    private val viewModelFactory: () -&gt; InputPhoneViewModel
) : ... {

    override fun createContentWidget() = with(theme) {
        val viewModel = getViewModel {
            viewModelFactory()
        }

        constraint(size = WidgetSize.AsParent) {
            val nameInput = +input(
                ...
                field = viewModel.phoneField
            )

            val submitButton = +button(
                ...
                onTap = viewModel::onSubmitPressed
            )

            ...
        }
    }
}
</code></pre>
<p>Из вне в экран передается фабрика <code>InputPhoneViewModel</code> через конструктор (внедрение зависимости позволяет ослабить связанность компонентов и реже вносить изменения в код экрана). Далее перед созданием виджетов мы получаем объект <code>InputPhoneViewModel</code> вызовом функции <code>getViewModel</code> (эта функция либо вернет существующую вьюмодель либо создаст новую). В лямбде <code>getViewModel</code> мы указываем как создать новую вьюмодель (в нашем случае вызовом <code>viewModelFactory</code>).<br>После получения <code>InputPhoneViewModel</code> мы можем привязать поле ввода к <code>phoneField</code> и обработчик нажатия кнопки <code>viewModel::onSubmitPressed</code> (таким образом передается функция объекта, чтобы не созадвать новую лямбду).</p>
<h2 is-upgraded>Добавление оповещения Screen&#39;а о необходимости перехода</h2>
<p>Теперь нам осталось сообщить из <code>InputPhoneViewModel</code> что нужно произвести переход на следующий экран. В реальной логике мы выполним запрос к серверу, передав туда телефон, а сервер отдаст нам токен, с которым мы дальше должны работать. Мы сделаем подобие этой логики в вьюмодели.</p>
<aside class="special"><p>Для связи <code>ViewModel</code> -&gt; <code>Screen</code> используются либо <code>LiveData</code>, которые автоматически подпишутся и отпишутся от получения изменений в нужный момент жизненного цикла либо <code>EventsDispatcher</code> (тоже работает учитывая жизненный цикл). Разница в том, что <code>LiveData</code> хранит постоянно значения, которые в ней записаны, а <code>EventsDispatcher</code> предназначен для разовых оповещенй, например &#34;перейди на следующий экран&#34; или &#34;покажи тост с ошибкой&#34;.</p>
</aside>
<pre><code>class InputPhoneViewModel(
    override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;
) : ViewModel(), EventsDispatcherOwner&lt;InputPhoneViewModel.EventsListener&gt; {

    val phoneField: FormField&lt;String, StringDesc&gt; = FormField(
        initialValue = &#34;&#34;,
        validation = liveBlock { null }
    )

    fun onSubmitPressed() {
        val token = &#34;token:&#34; + phoneField.data.value
        eventsDispatcher.dispatchEvent { routeInputCode(token) }
    }

    interface EventsListener {
        fun routeInputCode(token: String)
    }
}
</code></pre>
<p>В <code>InputPhoneViewModel</code> мы добавляем внутри интерфейс - <code>EventsListener</code>, это интерфейс со всеми событиями, которые может вызвать <code>ViewModel</code> у <code>Screen</code>‘а.<br>Когда уже есть интерфейс событий, нужно добавить к вьюмодели реализацию интерфейса <code>EventsDispatcherOwner&lt;InputPhoneViewModel.EventsListener&gt;</code> и добавить в конструктор <code>override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;</code> - сам <code>EventsDispatcher</code> передается из вне.<br>Остается вызвать у <code>eventsDispatcher</code> метод <code>dispatchEvent</code> в нужный момент и указать какой именно метод должен быть вызван у <code>Screen</code>‘а.</p>
<p>Для эмуляции действий сервера мы сформировали некую строку <code>token</code> и передаем ее в вызов <code>routeInputCode</code>.</p>
<h2 is-upgraded>Реакция Screen&#39;а на оповещения о необходимости перехода</h2>
<p>Теперь <code>ViewModel</code> имеет дополнительный аргумент в конструкторе, который должен быть передан самим экраном. А так же в <code>ViewModel</code> есть <code>eventsDispatcher</code>, на который нужно подписаться.</p>
<pre><code>class InputPhoneScreen(
    ...
    private val viewModelFactory: (
        EventsDispatcher&lt;InputPhoneViewModel.EventsListener&gt;
    ) -&gt; InputPhoneViewModel,
    private val routeInputCode: Route&lt;String&gt;
) : ..., InputPhoneViewModel.EventsListener {
    ...

    override fun createContentWidget() = with(theme) {
        val viewModel = getViewModel {
            viewModelFactory(createEventsDispatcher())
        }

        viewModel.eventsDispatcher.listen(this@InputPhoneScreen, this@InputPhoneScreen)

        ...
    }

    ...

    override fun routeInputCode(token: String) {
        routeInputCode.route(this, token)
    }
}
</code></pre>
<p>В данном коде мы добавили в лямбду фабрики вьюмодели что будет передан <code>EventsDispatcher</code>, а так же добавили в конструкторе <code>InputPhoneScreen</code> новый аргумент - <code>routeInputCode</code>.<br><code>routeInputCode</code> является типом <code>Route&lt;String&gt;</code> и обозначает, что экрану требуется предоставить способ перехода на экран ввода кода, при чем при переходе передаются данные типа <code>String</code>.<br>В получении вьюмодели методом <code>createEventsDispatcher</code> мы создаем новый <code>EventsDispatcher</code> (это происходит только в момент создания новой вьюмодели, а когда она уже есть создания не будет). После получения новой (или старой) вьюмодели, мы обращаемся к ее <code>eventsDispatcher</code> и подписываемся на события методом <code>listen</code>. Туда нужно передать сам экран (на его жизненный цикл будет завязана подписка) и объект, который будет слушать события по интерфейсу <code>InputPhoneViewModel.EventsListener</code> (в нашем случае это сам экран).<br>И сам переход выполняется вызовом метода <code>route</code> у <code>routeInputCode</code> с передачей текущего экрана и данных, которые отправляются (строка с токеном).</p>
<h2 is-upgraded>Добавление настроек навигации к экрану</h2>
<p>Экран <code>InputPhoneScreen</code> будет использоваться в <code>NavigationScreen</code> (это экран с <code>Toolbar</code>/<code>UINavigationBar</code>) и для получения настроек панели навигации <code>NavigationScreen</code> требует имплементации интефрейса <code>NavigationItem</code> у всех экранов, которые добавляются в <code>NavigationScreen</code>. Поэтому нам нужно добавить этот интерфейс и определить требуемые поля.</p>
<pre><code>class InputPhoneScreen(
    ...
) : ..., NavigationItem {

    override val navigationBar: NavigationBar get() = NavigationBar.Normal(&#34;Input phone&#34;.desc())

    ...
}
</code></pre>
<p>Интерфейс <code>NavigationItem</code> требует добавления свойства <code>navigationBar</code>, которое и определяет вид панели навигации (в нашем случае обычная навигация с заголовком &#34;Input phone&#34;).</p>


      </google-codelab-step>
    
      <google-codelab-step label="Авторизация - экран ввода кода" duration="20">
        <p>Экран ввода кода практически идентичен экрану ввода телефона. Имеются следующие отличия:</p>
<ul>
<li>Экран ввода кода требует передачи аргумента - <code>token: String</code>;</li>
<li>Переход дальше происходит на главный экран, без передачи каких либо данных;</li>
<li>Другое название в панели навигации;</li>
<li>Другое название поля ввода.</li>
</ul>
<h2 is-upgraded>Реализуем ViewModel</h2>
<pre><code>class InputCodeViewModel(
    override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;,
    private val token: String
) : ViewModel(), EventsDispatcherOwner&lt;InputCodeViewModel.EventsListener&gt; {

    val codeField: FormField&lt;String, StringDesc&gt; = FormField(
        initialValue = token,
        validation = liveBlock { null }
    )

    fun onSubmitPressed() {
        eventsDispatcher.dispatchEvent { routeMain() }
    }

    interface EventsListener {
        fun routeMain()
    }
}
</code></pre>
<p>В этой вьюмодели добавили аргумент в конструкторе вьюмодели - <code>token</code>, который должен передать нам предыдущий экран, а так же изменено имя поля (<code>codeField</code>) и роутинг не имеет аругментов (<code>routeMain</code>).<br>Для наглядности выставляем <code>token</code> как начальное значение поля <code>codeField</code> - так мы увидим что данные успешно переданы.</p>
<h2 is-upgraded>Реализуем экран</h2>
<pre><code>class InputCodeScreen(
    ...
    private val viewModelFactory: (
        eventsDispatcher: EventsDispatcher&lt;InputCodeViewModel.EventsListener&gt;,
        token: String
    ) -&gt; InputCodeViewModel,
    private val routeMain: Route&lt;Unit&gt;
) : WidgetScreen&lt;Args.Parcel&lt;InputCodeScreen.Arg&gt;&gt;(), InputCodeViewModel.EventsListener, ... {

    override val navigationBar: NavigationBar get() = NavigationBar.Normal(&#34;Input code&#34;.desc())

    override fun createContentWidget() = with(theme) {
        val viewModel = getViewModel {
            viewModelFactory(createEventsDispatcher(), getArgument().token)
        }

        ...

        constraint(size = WidgetSize.AsParent) {
            val nameInput = +input(
                ...
                label = const(&#34;Code&#34;),
                field = viewModel.codeField
            )

            ...
        }
    }

    ...

    override fun routeMain() {
        routeMain.route(this)
    }

    @Parcelize
    data class Arg(val token: String) : Parcelable
}
</code></pre>
<p>Основные отличия экрана <code>InputCodeScreen</code> от <code>InputPhoneScreen</code> это наличие аргумента.</p>
<p>Во первых добавлен класс <code>Arg</code>:</p>
<pre><code>@Parcelize
data class Arg(val token: String) : Parcelable
</code></pre>
<p>это должен быть <code>Parcelable</code> класс, чтобы android мог корректно его сохранять и передавать между экранами.</p>
<aside class="warning"><p>Для работы <code>Parcelable</code> надо включить плагин <code>id(&#34;kotlin-android-extensions&#34;)</code> в <code>mpp-library/build.gradle.kts</code></p>
</aside>
<p>Чтение аргумента происходит при создании вьюмодели, а лямбда <code>viewModelFactory</code> расширена аргументом <code>token</code>.</p>
<p>Переход <code>routeMain</code> имеет тип <code>Route&lt;Unit&gt;</code>. <code>Unit</code> означает что никаких данных передавать не требуется.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Авторизация - фабрика фичи" duration="10">
        <p>Для построения DI конкретной фичи (авторизации) добавим в пакете <code>org.example.mpp.auth</code> класс <code>AuthFactory</code>, которому из-вне потрубуется только <code>theme: Theme</code>.<br>В самом классе объявим функции создания экранов авторизации:</p>
<pre><code>class AuthFactory(
    private val theme: Theme
) {
    fun createInputPhoneScreen(routeInputCode: Route&lt;String&gt;): InputPhoneScreen {
        return InputPhoneScreen(
            theme = theme,
            viewModelFactory = { InputPhoneViewModel(it) },
            routeInputCode = routeInputCode
        )
    }

    fun createInputCodeScreen(routeMain: Route&lt;Unit&gt;): InputCodeScreen {
        return InputCodeScreen(
            theme = theme,
            viewModelFactory = { eventsDispatcher, token -&gt;
                InputCodeViewModel(eventsDispatcher, token)
            },
            routeMain = routeMain
        )
    }
}
</code></pre>
<p>При создании экранов так же передается из-вне путь до других экранов в навигации. например <code>routeMain</code> и <code>routeInputCode</code>.</p>
<p>Создадим объект <code>AuthFactory</code> в <code>App</code> и построим навигацию через <code>NavigationScreen</code>:</p>
<pre><code>class App : BaseApplication() {
    override fun setup(): ScreenDesc&lt;Args.Empty&gt; {
        val theme = Theme()

        val authFactory = AuthFactory(theme)

        return registerScreen(RootNavigationScreen::class) {
            val rootNavigationRouter = createRouter()

            val mainScreen = registerScreen(MainScreen::class) {
                MainScreen(theme)
            }

            val inputCodeScreen = registerScreen(InputCodeScreen::class) {
                authFactory.createInputCodeScreen(
                    routeMain = rootNavigationRouter.createReplaceRoute(mainScreen)
                )
            }

            val inputPhoneScreen = registerScreen(InputPhoneScreen::class) {
                authFactory.createInputPhoneScreen(
                    routeInputCode = rootNavigationRouter.createPushRoute(inputCodeScreen) {
                        InputCodeScreen.Arg(it)
                    }
                )
            }

            RootNavigationScreen(
                initialScreen = inputPhoneScreen,
                router = rootNavigationRouter
            )
        }
    }
}

class RootNavigationScreen(
    initialScreen: TypedScreenDesc&lt;Args.Empty, InputPhoneScreen&gt;,
    router: Router
) : NavigationScreen&lt;InputPhoneScreen&gt;(initialScreen, router)
</code></pre>
<p>Во первых <code>NavigationScreen</code> является <code>abstract</code> классом и требует наследоваться от него. Это сделанно из-за ограничения android платформы - пересоздание экранов происходит по имени класса в системе, из-за этого для разных экранов с разными входящими параметрами (то что передается в конструктор) должны быть использованы разные классы. По этой причине создан <code>RootNavigationScreen</code>, который является стартовым экраном приложения и регулирует всю навигацию приложения.</p>
<p>При регистрации экрана <code>RootNavigationScreen</code> в лямбде его создания мы имеем метод <code>createRouter</code>, который создает класс <a href="https://github.com/icerockdev/moko-widgets/blob/51f71df44a98a542ee012e58d996e554c9a1d1ef/widgets/src/commonMain/kotlin/dev/icerock/moko/widgets/screen/navigation/NavigationScreen.kt#L19" target="_blank"><br>NavigationScreen.Router</a>. Через <code>Router</code> мы можем создавать переходы (Push, Replace, Pop).</p>
<p>Далее для <code>RootNavigationScreen</code> требуется начальный экран, это у нас <code>InputPhoneScreen</code>, который мы зарегистирровали и сразу предаем ему путь до следующего экрана. Создание происходит так:</p>
<pre><code>routeInputCode = rootNavigationRouter.createPushRoute(inputCodeScreen) {
    InputCodeScreen.Arg(it)
}
</code></pre>
<p>В лямбде происходит преобразование данных, которые передает экран (<code>InputPhoneScreen</code>), в данном случае <code>String</code>, к данным, которые ожидает экран (<code>data class InputCodeScreen.Arg</code>).</p>
<p>Аналогичным способом регистрируется и экран <code>InputCodeScreen</code> с переходом на главный экран через <code>createReplaceRoute</code>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Авторизация - тестируем" duration="5">
        <p>Теперь можно скомпилировать проект и увидеть рабочую навигацию процесса авторизации.</p>
<h2 is-upgraded>Android</h2>
<table>
<tr></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-android-1" src="img/f8df91d82423b084.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-android-2" src="img/d08ceebf163fcb58.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-android-3" src="img/239af4a9c070abbe.png"></p>
</td></tr>
</table>
<h2 is-upgraded>iOS</h2>
<table>
<tr></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-ios-1" src="img/92031a5136dd4caf.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-ios-2" src="img/620f5a520c4b09e1.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-ios-3" src="img/7370305f5cdff3f4.png"></p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="Code of App" duration="30">
        <h2 is-upgraded>App.kt</h2>
<pre><code>package org.example.mpp

import dev.icerock.moko.resources.desc.desc
import dev.icerock.moko.widgets.core.Theme
import dev.icerock.moko.widgets.screen.Args
import dev.icerock.moko.widgets.screen.BaseApplication
import dev.icerock.moko.widgets.screen.ScreenDesc
import dev.icerock.moko.widgets.screen.TypedScreenDesc
import dev.icerock.moko.widgets.screen.navigation.BottomNavigationItem
import dev.icerock.moko.widgets.screen.navigation.BottomNavigationScreen
import dev.icerock.moko.widgets.screen.navigation.NavigationBar
import dev.icerock.moko.widgets.screen.navigation.NavigationItem
import dev.icerock.moko.widgets.screen.navigation.NavigationScreen
import dev.icerock.moko.widgets.screen.navigation.createPushResultRoute
import dev.icerock.moko.widgets.screen.navigation.createPushRoute
import dev.icerock.moko.widgets.screen.navigation.createReplaceRoute
import dev.icerock.moko.widgets.screen.navigation.createRouter
import org.example.mpp.auth.AuthFactory
import org.example.mpp.auth.InputCodeScreen
import org.example.mpp.auth.InputPhoneScreen
import org.example.mpp.info.InfoScreen
import org.example.mpp.profile.EditProfileScreen
import org.example.mpp.profile.ProfileFactory
import org.example.mpp.profile.ProfileScreen

class App : BaseApplication() {
    override fun setup(): ScreenDesc&lt;Args.Empty&gt; {
        val theme = Theme()

        val authFactory = AuthFactory(theme)
        val profileFactory = ProfileFactory(theme)

        return registerScreen(RootNavigationScreen::class) {
            val rootNavigationRouter = createRouter()

            val mainScreen = registerScreen(MainBottomNavigationScreen::class) {
                val bottomNavigationRouter = createRouter()

                val profileNavigationScreen = registerProfileTab(
                    profileFactory = profileFactory,
                    rootNavigationRouter = rootNavigationRouter
                )

                val infoScreen = registerScreen(InfoScreen::class) {
                    InfoScreen(theme = theme, routeProfile = bottomNavigationRouter.createChangeTabRoute(2))
                }

                MainBottomNavigationScreen(
                    router = bottomNavigationRouter
                ) {
                    tab(
                        id = 1,
                        title = &#34;Info&#34;.desc(),
                        icon = null,
                        screenDesc = infoScreen
                    )

                    tab(
                        id = 2,
                        title = &#34;Profile&#34;.desc(),
                        icon = null,
                        screenDesc = profileNavigationScreen
                    )
                }
            }

            val inputCodeScreen = registerScreen(InputCodeScreen::class) {
                authFactory.createInputCodeScreen(
                    routeMain = rootNavigationRouter.createReplaceRoute(mainScreen)
                )
            }

            val inputPhoneScreen = registerScreen(InputPhoneScreen::class) {
                authFactory.createInputPhoneScreen(
                    routeInputCode = rootNavigationRouter.createPushRoute(inputCodeScreen) {
                        InputCodeScreen.Arg(it)
                    }
                )
            }

            RootNavigationScreen(
                initialScreen = inputPhoneScreen,
                router = rootNavigationRouter
            )
        }
    }

    private fun registerProfileTab(
        profileFactory: ProfileFactory,
        rootNavigationRouter: NavigationScreen.Router
    ): TypedScreenDesc&lt;Args.Empty, ProfileNavigationScreen&gt; {
        return registerScreen(ProfileNavigationScreen::class) {
            val navigationRouter = createRouter()

            val profileEditScreen = registerScreen(EditProfileScreen::class) {
                profileFactory.createEditProfileScreen(
                    routeBack = navigationRouter.createPopRoute()
                )
            }

            val profileScreen = registerScreen(ProfileScreen::class) {
                profileFactory.createProfileScreen(
                    routeEdit = navigationRouter.createPushResultRoute(profileEditScreen) { it.edited },
                    routeLogout = rootNavigationRouter.createPopRoute()
                )
            }

            ProfileNavigationScreen(
                initialScreen = profileScreen,
                router = navigationRouter
            )
        }
    }
}

class RootNavigationScreen(
    initialScreen: TypedScreenDesc&lt;Args.Empty, InputPhoneScreen&gt;,
    router: Router
) : NavigationScreen&lt;InputPhoneScreen&gt;(initialScreen, router)

class MainBottomNavigationScreen(
    router: Router,
    builder: BottomNavigationItem.Builder.() -&gt; Unit
) : BottomNavigationScreen(router, builder), NavigationItem {
    override val navigationBar: NavigationBar = NavigationBar.None
}

class ProfileNavigationScreen(
    initialScreen: TypedScreenDesc&lt;Args.Empty, ProfileScreen&gt;,
    router: Router
) : NavigationScreen&lt;ProfileScreen&gt;(initialScreen, router)
</code></pre>
<h2 is-upgraded>auth/AuthFactory.kt</h2>
<pre><code>package org.example.mpp.auth

import dev.icerock.moko.widgets.core.Theme
import dev.icerock.moko.widgets.screen.navigation.Route

class AuthFactory(
    private val theme: Theme
) {
    fun createInputPhoneScreen(routeInputCode: Route&lt;String&gt;): InputPhoneScreen {
        return InputPhoneScreen(
            theme = theme,
            viewModelFactory = { InputPhoneViewModel(it) },
            routeInputCode = routeInputCode
        )
    }

    fun createInputCodeScreen(routeMain: Route&lt;Unit&gt;): InputCodeScreen {
        return InputCodeScreen(
            theme = theme,
            viewModelFactory = { eventsDispatcher, token -&gt;
                InputCodeViewModel(eventsDispatcher, token)
            },
            routeMain = routeMain
        )
    }
}
</code></pre>
<h2 is-upgraded>auth/InputPhoneScreen.kt</h2>
<pre><code>package org.example.mpp.auth

import dev.icerock.moko.fields.FormField
import dev.icerock.moko.fields.liveBlock
import dev.icerock.moko.mvvm.dispatcher.EventsDispatcher
import dev.icerock.moko.mvvm.dispatcher.EventsDispatcherOwner
import dev.icerock.moko.mvvm.viewmodel.ViewModel
import dev.icerock.moko.resources.desc.StringDesc
import dev.icerock.moko.resources.desc.desc
import dev.icerock.moko.widgets.ButtonWidget
import dev.icerock.moko.widgets.InputWidget
import dev.icerock.moko.widgets.button
import dev.icerock.moko.widgets.constraint
import dev.icerock.moko.widgets.core.Theme
import dev.icerock.moko.widgets.core.Value
import dev.icerock.moko.widgets.input
import dev.icerock.moko.widgets.screen.Args
import dev.icerock.moko.widgets.screen.WidgetScreen
import dev.icerock.moko.widgets.screen.getViewModel
import dev.icerock.moko.widgets.screen.listen
import dev.icerock.moko.widgets.screen.navigation.NavigationBar
import dev.icerock.moko.widgets.screen.navigation.NavigationItem
import dev.icerock.moko.widgets.screen.navigation.Route
import dev.icerock.moko.widgets.style.view.WidgetSize

class InputPhoneScreen(
    private val theme: Theme,
    private val viewModelFactory: (
        EventsDispatcher&lt;InputPhoneViewModel.EventsListener&gt;
    ) -&gt; InputPhoneViewModel,
    private val routeInputCode: Route&lt;String&gt;
) : WidgetScreen&lt;Args.Empty&gt;(), InputPhoneViewModel.EventsListener, NavigationItem {

    override val navigationBar: NavigationBar get() = NavigationBar.Normal(&#34;Input phone&#34;.desc())

    override fun createContentWidget() = with(theme) {
        val viewModel = getViewModel {
            viewModelFactory(createEventsDispatcher())
        }

        viewModel.eventsDispatcher.listen(this@InputPhoneScreen, this@InputPhoneScreen)

        constraint(size = WidgetSize.AsParent) {
            val nameInput = +input(
                size = WidgetSize.WidthAsParentHeightWrapContent,
                id = Ids.Phone,
                label = const(&#34;Phone&#34;),
                field = viewModel.phoneField
            )

            val submitButton = +button(
                size = WidgetSize.WidthAsParentHeightWrapContent,
                content = ButtonWidget.Content.Text(Value.data(&#34;Submit&#34;.desc())),
                onTap = viewModel::onSubmitPressed
            )

            constraints {
                nameInput centerYToCenterY root
                nameInput leftRightToLeftRight root offset 16

                submitButton bottomToBottom root.safeArea offset 16
                submitButton leftRightToLeftRight root offset 16
            }
        }
    }

    object Ids {
        object Phone : InputWidget.Id
    }

    override fun routeInputCode(token: String) {
        routeInputCode.route(this, token)
    }
}

class InputPhoneViewModel(
    override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;
) : ViewModel(), EventsDispatcherOwner&lt;InputPhoneViewModel.EventsListener&gt; {

    val phoneField: FormField&lt;String, StringDesc&gt; = FormField(
        initialValue = &#34;&#34;,
        validation = liveBlock { null }
    )

    fun onSubmitPressed() {
        val token = &#34;token:&#34; + phoneField.data.value
        eventsDispatcher.dispatchEvent { routeInputCode(token) }
    }

    interface EventsListener {
        fun routeInputCode(token: String)
    }
}
</code></pre>
<h2 is-upgraded>auth/InputCodeScreen.kt</h2>
<pre><code>package org.example.mpp.auth

import dev.icerock.moko.fields.FormField
import dev.icerock.moko.fields.liveBlock
import dev.icerock.moko.mvvm.dispatcher.EventsDispatcher
import dev.icerock.moko.mvvm.dispatcher.EventsDispatcherOwner
import dev.icerock.moko.mvvm.viewmodel.ViewModel
import dev.icerock.moko.parcelize.Parcelable
import dev.icerock.moko.parcelize.Parcelize
import dev.icerock.moko.resources.desc.StringDesc
import dev.icerock.moko.resources.desc.desc
import dev.icerock.moko.widgets.ButtonWidget
import dev.icerock.moko.widgets.InputWidget
import dev.icerock.moko.widgets.button
import dev.icerock.moko.widgets.constraint
import dev.icerock.moko.widgets.core.Theme
import dev.icerock.moko.widgets.core.Value
import dev.icerock.moko.widgets.input
import dev.icerock.moko.widgets.screen.Args
import dev.icerock.moko.widgets.screen.WidgetScreen
import dev.icerock.moko.widgets.screen.getArgument
import dev.icerock.moko.widgets.screen.getViewModel
import dev.icerock.moko.widgets.screen.listen
import dev.icerock.moko.widgets.screen.navigation.NavigationBar
import dev.icerock.moko.widgets.screen.navigation.NavigationItem
import dev.icerock.moko.widgets.screen.navigation.Route
import dev.icerock.moko.widgets.screen.navigation.route
import dev.icerock.moko.widgets.style.view.WidgetSize

class InputCodeScreen(
    private val theme: Theme,
    private val viewModelFactory: (
        eventsDispatcher: EventsDispatcher&lt;InputCodeViewModel.EventsListener&gt;,
        token: String
    ) -&gt; InputCodeViewModel,
    private val routeMain: Route&lt;Unit&gt;
) : WidgetScreen&lt;Args.Parcel&lt;InputCodeScreen.Arg&gt;&gt;(), InputCodeViewModel.EventsListener, NavigationItem {

    override val navigationBar: NavigationBar get() = NavigationBar.Normal(&#34;Input code&#34;.desc())

    override fun createContentWidget() = with(theme) {
        val viewModel = getViewModel {
            viewModelFactory(createEventsDispatcher(), getArgument().token)
        }

        viewModel.eventsDispatcher.listen(this@InputCodeScreen, this@InputCodeScreen)

        constraint(size = WidgetSize.AsParent) {
            val nameInput = +input(
                size = WidgetSize.WidthAsParentHeightWrapContent,
                id = Ids.Code,
                label = const(&#34;Code&#34;),
                field = viewModel.codeField
            )

            val submitButton = +button(
                size = WidgetSize.WidthAsParentHeightWrapContent,
                content = ButtonWidget.Content.Text(Value.data(&#34;Submit&#34;.desc())),
                onTap = viewModel::onSubmitPressed
            )

            constraints {
                nameInput centerYToCenterY root
                nameInput leftRightToLeftRight root offset 16

                submitButton bottomToBottom root.safeArea offset 16
                submitButton leftRightToLeftRight root offset 16
            }
        }
    }

    object Ids {
        object Code : InputWidget.Id
    }

    override fun routeMain() {
        routeMain.route(this)
    }

    @Parcelize
    data class Arg(val token: String) : Parcelable
}

class InputCodeViewModel(
    override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;,
    private val token: String
) : ViewModel(), EventsDispatcherOwner&lt;InputCodeViewModel.EventsListener&gt; {

    val codeField: FormField&lt;String, StringDesc&gt; = FormField(
        initialValue = token,
        validation = liveBlock { null }
    )

    fun onSubmitPressed() {
        eventsDispatcher.dispatchEvent { routeMain() }
    }

    interface EventsListener {
        fun routeMain()
    }
}
</code></pre>
<h2 is-upgraded>info/InfoScreen.kt</h2>
<pre><code>package org.example.mpp.info

import dev.icerock.moko.resources.desc.desc
import dev.icerock.moko.widgets.ButtonWidget
import dev.icerock.moko.widgets.button
import dev.icerock.moko.widgets.constraint
import dev.icerock.moko.widgets.core.Theme
import dev.icerock.moko.widgets.core.Value
import dev.icerock.moko.widgets.screen.Args
import dev.icerock.moko.widgets.screen.WidgetScreen
import dev.icerock.moko.widgets.screen.navigation.Route
import dev.icerock.moko.widgets.screen.navigation.route
import dev.icerock.moko.widgets.style.view.WidgetSize

class InfoScreen(
    private val theme: Theme,
    private val routeProfile: Route&lt;Unit&gt;
) : WidgetScreen&lt;Args.Empty&gt;() {

    override fun createContentWidget() = with(theme) {
        constraint(size = WidgetSize.AsParent) {
            val submitButton = +button(
                size = WidgetSize.WidthAsParentHeightWrapContent,
                content = ButtonWidget.Content.Text(Value.data(&#34;Profile&#34;.desc()))
            ) {
                routeProfile.route(this@InfoScreen)
            }

            constraints {
                submitButton centerYToCenterY root
                submitButton centerXToCenterX root
            }
        }
    }
}
</code></pre>
<h2 is-upgraded>profile/ProfileFactory.kt</h2>
<pre><code>package org.example.mpp.profile

import dev.icerock.moko.widgets.core.Theme
import dev.icerock.moko.widgets.screen.navigation.Route
import dev.icerock.moko.widgets.screen.navigation.RouteWithResult

class ProfileFactory(
    private val theme: Theme
) {
    fun createProfileScreen(
        routeEdit: RouteWithResult&lt;Unit, Boolean&gt;,
        routeLogout: Route&lt;Unit&gt;
    ): ProfileScreen {
        return ProfileScreen(
            theme = theme,
            routeEdit = routeEdit,
            routeLogout = routeLogout
        )
    }

    fun createEditProfileScreen(
        routeBack: Route&lt;Unit&gt;
    ): EditProfileScreen {
        return EditProfileScreen(
            theme = theme,
            routeBack = routeBack
        )
    }
}
</code></pre>
<h2 is-upgraded>profile/ProfileScreen.kt</h2>
<pre><code>package org.example.mpp.profile

import dev.icerock.moko.resources.desc.desc
import dev.icerock.moko.widgets.ButtonWidget
import dev.icerock.moko.widgets.button
import dev.icerock.moko.widgets.constraint
import dev.icerock.moko.widgets.core.Theme
import dev.icerock.moko.widgets.core.Value
import dev.icerock.moko.widgets.screen.Args
import dev.icerock.moko.widgets.screen.WidgetScreen
import dev.icerock.moko.widgets.screen.navigation.NavigationBar
import dev.icerock.moko.widgets.screen.navigation.NavigationItem
import dev.icerock.moko.widgets.screen.navigation.Route
import dev.icerock.moko.widgets.screen.navigation.RouteWithResult
import dev.icerock.moko.widgets.screen.navigation.registerRouteHandler
import dev.icerock.moko.widgets.screen.navigation.route
import dev.icerock.moko.widgets.style.view.WidgetSize

class ProfileScreen(
    private val theme: Theme,
    private val routeEdit: RouteWithResult&lt;Unit, Boolean&gt;,
    private val routeLogout: Route&lt;Unit&gt;
) : WidgetScreen&lt;Args.Empty&gt;(), NavigationItem {

    override val navigationBar: NavigationBar get() = NavigationBar.Normal(&#34;Profile&#34;.desc())

    private val editHandler by registerRouteHandler(code = 9, route = routeEdit) {
        println(&#34;profile edited: $it&#34;)
    }

    override fun createContentWidget() = with(theme) {
        constraint(size = WidgetSize.AsParent) {
            val editButton = +button(
                size = WidgetSize.WidthAsParentHeightWrapContent,
                content = ButtonWidget.Content.Text(Value.data(&#34;Edit&#34;.desc()))
            ) {
                routeEdit.route(this@ProfileScreen, editHandler)
            }

            val logoutButton = +button(
                size = WidgetSize.WidthAsParentHeightWrapContent,
                content = ButtonWidget.Content.Text(Value.data(&#34;Logout&#34;.desc()))
            ) {
                routeLogout.route(this@ProfileScreen)
            }

            constraints {
                editButton centerYToCenterY root
                editButton centerXToCenterX root

                logoutButton centerXToCenterX root
                logoutButton topToBottom editButton
            }
        }
    }
}
</code></pre>
<h2 is-upgraded>profile/EditProfileScreen.kt</h2>
<pre><code>package org.example.mpp.profile

import dev.icerock.moko.parcelize.Parcelable
import dev.icerock.moko.parcelize.Parcelize
import dev.icerock.moko.resources.desc.desc
import dev.icerock.moko.widgets.ButtonWidget
import dev.icerock.moko.widgets.button
import dev.icerock.moko.widgets.constraint
import dev.icerock.moko.widgets.core.Theme
import dev.icerock.moko.widgets.core.Value
import dev.icerock.moko.widgets.screen.Args
import dev.icerock.moko.widgets.screen.WidgetScreen
import dev.icerock.moko.widgets.screen.navigation.NavigationBar
import dev.icerock.moko.widgets.screen.navigation.NavigationItem
import dev.icerock.moko.widgets.screen.navigation.Resultable
import dev.icerock.moko.widgets.screen.navigation.Route
import dev.icerock.moko.widgets.screen.navigation.route
import dev.icerock.moko.widgets.style.view.WidgetSize

class EditProfileScreen(
    private val theme: Theme,
    private val routeBack: Route&lt;Unit&gt;
) : WidgetScreen&lt;Args.Empty&gt;(), Resultable&lt;EditProfileScreen.Result&gt;, NavigationItem {

    override val navigationBar: NavigationBar get() = NavigationBar.Normal(&#34;Edit profile&#34;.desc())

    override var screenResult: Result? = null

    override fun createContentWidget() = with(theme) {
        constraint(size = WidgetSize.AsParent) {
            val close1Btn = +button(
                size = WidgetSize.WidthAsParentHeightWrapContent,
                content = ButtonWidget.Content.Text(
                    Value.data(
                        &#34;Close not edited&#34;.desc()
                    )
                )
            ) {
                screenResult = Result(false)
                routeBack.route(this@EditProfileScreen)
            }

            val close2Btn = +button(
                size = WidgetSize.WidthAsParentHeightWrapContent,
                content = ButtonWidget.Content.Text(
                    Value.data(
                        &#34;Close edited&#34;.desc()
                    )
                )
            ) {
                screenResult = Result(true)
                routeBack.route(this@EditProfileScreen)
            }

            constraints {
                close1Btn centerYToCenterY root
                close1Btn centerXToCenterX root

                close2Btn centerXToCenterX root
                close2Btn topToBottom close1Btn
            }
        }
    }

    @Parcelize
    data class Result(val edited: Boolean) : Parcelable
}
</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
