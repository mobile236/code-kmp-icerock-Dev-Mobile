
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>MOKO Widgets #2 - routing</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="UA-81805223-5"
                  id="moko-widgets-2"
                  title="MOKO Widgets #2 - routing"
                  environment="web"
                  feedback-link="https://github.com/icerockdev/kmp-codelabs/issues">
    
      <google-codelab-step label="Вводная" duration="5">
        <p>Урок является продолжением <a href="https://codelabs.kmp.icerock.dev/codelabs/moko-widgets-1/" target="_blank">MOKO Widgets #1 - hello world</a>. Для выполнения данного урока нужно иметь проект, полученный в результате выполнения предыдущего урока.</p>
<p>Результатом прошлого урока был экран входа с полем ввода имени и кнопкой отправки:</p>
<table>
<tr></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img alt="android-app" src="img/9576e0146a71f98f.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="ios-app" src="img/35e157c9148e2dab.png"></p>
</td></tr>
</table>
<p>На этом уроке мы добавим навигацию между экранами. Схема переходов будет следующая:<br><img alt="navigation-scheme" src="img/639f7f0c1a0b8b90.jpg"><br>Будут разобраны переходы:</p>
<ul>
<li>Обычный переход вперед;</li>
<li>Переход назад;</li>
<li>Переход вперед с передачей данных;</li>
<li>Нижняя навигация табами;</li>
<li>Переход с обработкой возвращаемого результата.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Обновляем свой проект" duration="2">
        <p>В этом уроке потребуется обновленная версия moko-widgets, поэтому сначала требуется обновиться до версии <a href="https://github.com/icerockdev/moko-widgets/releases/tag/release%2F0.1.0-dev-7" target="_blank">0.1.0-dev-7</a>.<br>Изменения, которые нужно сделать можно посмотреть в <a href="https://github.com/icerockdev/moko-widgets-template/commit/a617b9bfc6e42fa4203253825d7e530fc496a4d2" target="_blank">коммите</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Схема авторизации" duration="2">
        <p>Согласно схеме экранов процесс авторизации состоит из 2 экранов, после чего переход выполняется на главную.<br><img alt="navigation-scheme" src="img/639f7f0c1a0b8b90.jpg"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Авторизация - экран ввода телефона" duration="30">
        <p>Переименуем полученный на прошлом уроке <code>LoginScreen</code> в <code>InputPhoneScreen</code> и перенесем в пакет <code>org.example.mpp.auth</code> - в нем соберем все классы относящиеся к авторизации, при чем сделаем это так, чтобы никаких внешних зависимостей у классов лежащих в этом пакете не было. Это позволит вынести эти классы в отдельный gradle модуль (разделение по фичам).</p>
<h2 is-upgraded>Реализация ViewModel</h2>
<p>Далее реализуем обработку действий пользователя, для этого заведем <code>InputPhoneViewModel</code>, в которой будет <code>phoneField</code> (ранее мы просто создавали инстанс поля не запоминая ссылку на него. Этот объект требуется для <code>input</code> виджета).</p>
<pre><code>class InputPhoneViewModel() : ViewModel() {

    val phoneField: FormField&lt;String, StringDesc&gt; = FormField(
        initialValue = &#34;&#34;,
        validation = liveBlock { null }
    )

    fun onSubmitPressed() {
        val phone = phoneField.data.value
        println(&#34;phone: $phone&#34;)
    }
}
</code></pre>
<p>Описанная выше <code>ViewModel</code> содержит в себе поле ввода телефона, с выключенной валидацией (блок <code>liveBlock { null}</code> означает ошибки всегда нет), а так же обработчик нажатия <code>onSubmitPressed</code>, который выведет введенный телефон в лог.</p>
<h2 is-upgraded>Привязка Screen к ViewModel</h2>
<p>Теперь нужно привязать экран к <code>InputPhoneViewModel</code>.</p>
<aside class="special"><p><code>ViewModel</code> переживает смену конфигурации на android. Это означает что если пользователь повернет экран или сменит язык в системе или включит разделение экрана, то данные, которые хранятся в <code>ViewModel</code>, а так же и все действия которые она выполняет, останутся доступны и новый пересозданный системой экран подключится к старой вьюмодели, без потерь данных. Чтобы эта логика работала нужно использовать функции получения <code>ViewModel</code> у <code>Screen</code>: <code>getViewModel {}</code> где в лямбде указывается как создать новую вьюмодель, если старой еще нет.</p>
</aside>
<pre><code>class InputPhoneScreen(
    ...
    private val viewModelFactory: () -&gt; InputPhoneViewModel
) : ... {

    override fun createContentWidget() = with(theme) {
        val viewModel = getViewModel {
            viewModelFactory()
        }

        constraint(size = WidgetSize.AsParent) {
            val nameInput = +input(
                ...
                field = viewModel.phoneField
            )

            val submitButton = +button(
                ...
                onTap = viewModel::onSubmitPressed
            )

            ...
        }
    }
}
</code></pre>
<p>Из вне в экран передается фабрика <code>InputPhoneViewModel</code> через конструктор (внедрение зависимости позволяет ослабить связанность компонентов и реже вносить изменения в код экрана). Далее перед созданием виджетов мы получаем объект <code>InputPhoneViewModel</code> вызовом функции <code>getViewModel</code> (эта функция либо вернет существующую вьюмодель либо создаст новую). В лямбде <code>getViewModel</code> мы указываем как создать новую вьюмодель (в нашем случае вызовом <code>viewModelFactory</code>).<br>После получения <code>InputPhoneViewModel</code> мы можем привязать поле ввода к <code>phoneField</code> и обработчик нажатия кнопки <code>viewModel::onSubmitPressed</code> (таким образом передается функция объекта, чтобы не созадвать новую лямбду).</p>
<h2 is-upgraded>Добавление оповещения Screen&#39;а о необходимости перехода</h2>
<p>Теперь нам осталось сообщить из <code>InputPhoneViewModel</code> что нужно произвести переход на следующий экран. В реальной логике мы выполним запрос к серверу, передав туда телефон, а сервер отдаст нам токен, с которым мы дальше должны работать. Мы сделаем подобие этой логики в вьюмодели.</p>
<aside class="special"><p>Для связи <code>ViewModel</code> -&gt; <code>Screen</code> используются либо <code>LiveData</code>, которые автоматически подпишутся и отпишутся от получения изменений в нужный момент жизненного цикла либо <code>EventsDispatcher</code> (тоже работает учитывая жизненный цикл). Разница в том, что <code>LiveData</code> хранит постоянно значения, которые в ней записаны, а <code>EventsDispatcher</code> предназначен для разовых оповещенй, например &#34;перейди на следующий экран&#34; или &#34;покажи тост с ошибкой&#34;.</p>
</aside>
<pre><code>class InputPhoneViewModel(
    override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;
) : ViewModel(), EventsDispatcherOwner&lt;InputPhoneViewModel.EventsListener&gt; {

    val phoneField: FormField&lt;String, StringDesc&gt; = FormField(
        initialValue = &#34;&#34;,
        validation = liveBlock { null }
    )

    fun onSubmitPressed() {
        val token = &#34;token:&#34; + phoneField.data.value
        eventsDispatcher.dispatchEvent { routeInputCode(token) }
    }

    interface EventsListener {
        fun routeInputCode(token: String)
    }
}
</code></pre>
<p>В <code>InputPhoneViewModel</code> мы добавляем внутри интерфейс - <code>EventsListener</code>, это интерфейс со всеми событиями, которые может вызвать <code>ViewModel</code> у <code>Screen</code>‘а.<br>Когда уже есть интерфейс событий, нужно добавить к вьюмодели реализацию интерфейса <code>EventsDispatcherOwner&lt;InputPhoneViewModel.EventsListener&gt;</code> и добавить в конструктор <code>override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;</code> - сам <code>EventsDispatcher</code> передается из вне.<br>Остается вызвать у <code>eventsDispatcher</code> метод <code>dispatchEvent</code> в нужный момент и указать какой именно метод должен быть вызван у <code>Screen</code>‘а.</p>
<p>Для эмуляции действий сервера мы сформировали некую строку <code>token</code> и передаем ее в вызов <code>routeInputCode</code>.</p>
<h2 is-upgraded>Реакция Screen&#39;а на оповещения о необходимости перехода</h2>
<p>Теперь <code>ViewModel</code> имеет дополнительный аргумент в конструкторе, который должен быть передан самим экраном. А так же в <code>ViewModel</code> есть <code>eventsDispatcher</code>, на который нужно подписаться.</p>
<pre><code>class InputPhoneScreen(
    ...
    private val viewModelFactory: (
        EventsDispatcher&lt;InputPhoneViewModel.EventsListener&gt;
    ) -&gt; InputPhoneViewModel,
    private val routeInputCode: Route&lt;String&gt;
) : ..., InputPhoneViewModel.EventsListener {
    ...

    override fun createContentWidget() = with(theme) {
        val viewModel = getViewModel {
            viewModelFactory(createEventsDispatcher())
        }

        viewModel.eventsDispatcher.listen(this@InputPhoneScreen, this@InputPhoneScreen)

        ...
    }

    ...

    override fun routeInputCode(token: String) {
        routeInputCode.route(this, token)
    }
}
</code></pre>
<p>В данном коде мы добавили в лямбду фабрики вьюмодели что будет передан <code>EventsDispatcher</code>, а так же добавили в конструкторе <code>InputPhoneScreen</code> новый аргумент - <code>routeInputCode</code>.<br><code>routeInputCode</code> является типом <code>Route&lt;String&gt;</code> и обозначает, что экрану требуется предоставить способ перехода на экран ввода кода, при чем при переходе передаются данные типа <code>String</code>.<br>В получении вьюмодели методом <code>createEventsDispatcher</code> мы создаем новый <code>EventsDispatcher</code> (это происходит только в момент создания новой вьюмодели, а когда она уже есть создания не будет). После получения новой (или старой) вьюмодели, мы обращаемся к ее <code>eventsDispatcher</code> и подписываемся на события методом <code>listen</code>. Туда нужно передать сам экран (на его жизненный цикл будет завязана подписка) и объект, который будет слушать события по интерфейсу <code>InputPhoneViewModel.EventsListener</code> (в нашем случае это сам экран).<br>И сам переход выполняется вызовом метода <code>route</code> у <code>routeInputCode</code> с передачей текущего экрана и данных, которые отправляются (строка с токеном).</p>
<h2 is-upgraded>Добавление настроек навигации к экрану</h2>
<p>Экран <code>InputPhoneScreen</code> будет использоваться в <code>NavigationScreen</code> (это экран с <code>Toolbar</code>/<code>UINavigationBar</code>) и для получения настроек панели навигации <code>NavigationScreen</code> требует имплементации интефрейса <code>NavigationItem</code> у всех экранов, которые добавляются в <code>NavigationScreen</code>. Поэтому нам нужно добавить этот интерфейс и определить требуемые поля.</p>
<pre><code>class InputPhoneScreen(
    ...
) : ..., NavigationItem {

    override val navigationBar: NavigationBar get() = NavigationBar.Normal(&#34;Input phone&#34;.desc())

    ...
}
</code></pre>
<p>Интерфейс <code>NavigationItem</code> требует добавления свойства <code>navigationBar</code>, которое и определяет вид панели навигации (в нашем случае обычная навигация с заголовком &#34;Input phone&#34;).</p>


      </google-codelab-step>
    
      <google-codelab-step label="Авторизация - экран ввода кода" duration="20">
        <p>Экран ввода кода практически идентичен экрану ввода телефона. Имеются следующие отличия:</p>
<ul>
<li>Экран ввода кода требует передачи аргумента - <code>token: String</code>;</li>
<li>Переход дальше происходит на главный экран, без передачи каких либо данных;</li>
<li>Другое название в панели навигации;</li>
<li>Другое название поля ввода.</li>
</ul>
<h2 is-upgraded>Реализуем ViewModel</h2>
<pre><code>class InputCodeViewModel(
    override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;,
    private val token: String
) : ViewModel(), EventsDispatcherOwner&lt;InputCodeViewModel.EventsListener&gt; {

    val codeField: FormField&lt;String, StringDesc&gt; = FormField(
        initialValue = token,
        validation = liveBlock { null }
    )

    fun onSubmitPressed() {
        eventsDispatcher.dispatchEvent { routeMain() }
    }

    interface EventsListener {
        fun routeMain()
    }
}
</code></pre>
<p>В этой вьюмодели добавили аргумент в конструкторе вьюмодели - <code>token</code>, который должен передать нам предыдущий экран, а так же изменено имя поля (<code>codeField</code>) и роутинг не имеет аругментов (<code>routeMain</code>).<br>Для наглядности выставляем <code>token</code> как начальное значение поля <code>codeField</code> - так мы увидим что данные успешно переданы.</p>
<h2 is-upgraded>Реализуем экран</h2>
<pre><code>class InputCodeScreen(
    ...
    private val viewModelFactory: (
        eventsDispatcher: EventsDispatcher&lt;InputCodeViewModel.EventsListener&gt;,
        token: String
    ) -&gt; InputCodeViewModel,
    private val routeMain: Route&lt;Unit&gt;
) : WidgetScreen&lt;Args.Parcel&lt;InputCodeScreen.Arg&gt;&gt;(), InputCodeViewModel.EventsListener, ... {

    override val navigationBar: NavigationBar get() = NavigationBar.Normal(&#34;Input code&#34;.desc())

    override fun createContentWidget() = with(theme) {
        val viewModel = getViewModel {
            viewModelFactory(createEventsDispatcher(), getArgument().token)
        }

        ...

        constraint(size = WidgetSize.AsParent) {
            val nameInput = +input(
                ...
                label = const(&#34;Code&#34;),
                field = viewModel.codeField
            )

            ...
        }
    }

    ...

    override fun routeMain() {
        routeMain.route(this)
    }

    @Parcelize
    data class Arg(val token: String) : Parcelable
}
</code></pre>
<p>Основные отличия экрана <code>InputCodeScreen</code> от <code>InputPhoneScreen</code> это наличие аргумента.</p>
<p>Во первых добавлен класс <code>Arg</code>:</p>
<pre><code>@Parcelize
data class Arg(val token: String) : Parcelable
</code></pre>
<p>это должен быть <code>Parcelable</code> класс, чтобы android мог корректно его сохранять и передавать между экранами.</p>
<aside class="warning"><p>Для работы <code>Parcelable</code> надо включить плагин <code>id(&#34;kotlin-android-extensions&#34;)</code> в <code>mpp-library/build.gradle.kts</code></p>
</aside>
<p>Чтение аргумента происходит при создании вьюмодели, а лямбда <code>viewModelFactory</code> расширена аргументом <code>token</code>.</p>
<p>Переход <code>routeMain</code> имеет тип <code>Route&lt;Unit&gt;</code>. <code>Unit</code> означает что никаких данных передавать не требуется.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Авторизация - фабрика фичи" duration="10">
        <p>Для построения DI конкретной фичи (авторизации) добавим в пакете <code>org.example.mpp.auth</code> класс <code>AuthFactory</code>, которому из-вне потрубуется только <code>theme: Theme</code>.<br>В самом классе объявим функции создания экранов авторизации:</p>
<pre><code>class AuthFactory(
    private val theme: Theme
) {
    fun createInputPhoneScreen(routeInputCode: Route&lt;String&gt;): InputPhoneScreen {
        return InputPhoneScreen(
            theme = theme,
            viewModelFactory = { InputPhoneViewModel(it) },
            routeInputCode = routeInputCode
        )
    }

    fun createInputCodeScreen(routeMain: Route&lt;Unit&gt;): InputCodeScreen {
        return InputCodeScreen(
            theme = theme,
            viewModelFactory = { eventsDispatcher, token -&gt;
                InputCodeViewModel(eventsDispatcher, token)
            },
            routeMain = routeMain
        )
    }
}
</code></pre>
<p>При создании экранов так же передается из-вне путь до других экранов в навигации. например <code>routeMain</code> и <code>routeInputCode</code>.</p>
<p>Создадим объект <code>AuthFactory</code> в <code>App</code> и построим навигацию через <code>NavigationScreen</code>:</p>
<pre><code>class App : BaseApplication() {
    override fun setup(): ScreenDesc&lt;Args.Empty&gt; {
        val theme = Theme()

        val authFactory = AuthFactory(theme)

        return registerScreen(RootNavigationScreen::class) {
            val rootNavigationRouter = createRouter()

            val mainScreen = registerScreen(MainScreen::class) {
                MainScreen(theme)
            }

            val inputCodeScreen = registerScreen(InputCodeScreen::class) {
                authFactory.createInputCodeScreen(
                    routeMain = rootNavigationRouter.createReplaceRoute(mainScreen)
                )
            }

            val inputPhoneScreen = registerScreen(InputPhoneScreen::class) {
                authFactory.createInputPhoneScreen(
                    routeInputCode = rootNavigationRouter.createPushRoute(inputCodeScreen) {
                        InputCodeScreen.Arg(it)
                    }
                )
            }

            RootNavigationScreen(
                initialScreen = inputPhoneScreen,
                router = rootNavigationRouter
            )
        }
    }
}

class RootNavigationScreen(
    initialScreen: TypedScreenDesc&lt;Args.Empty, InputPhoneScreen&gt;,
    router: Router
) : NavigationScreen&lt;InputPhoneScreen&gt;(initialScreen, router)
</code></pre>
<p>Во первых <code>NavigationScreen</code> является <code>abstract</code> классом и требует наследоваться от него. Это сделанно из-за ограничения android платформы - пересоздание экранов происходит по имени класса в системе, из-за этого для разных экранов с разными входящими параметрами (то что передается в конструктор) должны быть использованы разные классы. По этой причине создан <code>RootNavigationScreen</code>, который является стартовым экраном приложения и регулирует всю навигацию приложения.</p>
<p>При регистрации экрана <code>RootNavigationScreen</code> в лямбде его создания мы имеем метод <code>createRouter</code>, который создает класс <a href="https://github.com/icerockdev/moko-widgets/blob/51f71df44a98a542ee012e58d996e554c9a1d1ef/widgets/src/commonMain/kotlin/dev/icerock/moko/widgets/screen/navigation/NavigationScreen.kt#L19" target="_blank"><br>NavigationScreen.Router</a>. Через <code>Router</code> мы можем создавать переходы (Push, Replace, Pop).</p>
<p>Далее для <code>RootNavigationScreen</code> требуется начальный экран, это у нас <code>InputPhoneScreen</code>, который мы зарегистирровали и сразу предаем ему путь до следующего экрана. Создание происходит так:</p>
<pre><code>routeInputCode = rootNavigationRouter.createPushRoute(inputCodeScreen) {
    InputCodeScreen.Arg(it)
}
</code></pre>
<p>В лямбде происходит преобразование данных, которые передает экран (<code>InputPhoneScreen</code>), в данном случае <code>String</code>, к данным, которые ожидает экран (<code>data class InputCodeScreen.Arg</code>).</p>
<p>Аналогичным способом регистрируется и экран <code>InputCodeScreen</code> с переходом на главный экран через <code>createReplaceRoute</code>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Авторизация - тестируем" duration="5">
        <p>Теперь можно скомпилировать проект и увидеть рабочую навигацию процесса авторизации.</p>
<h2 is-upgraded>Android</h2>
<table>
<tr></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-android-1" src="img/f8df91d82423b084.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-android-2" src="img/d08ceebf163fcb58.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-android-3" src="img/239af4a9c070abbe.png"></p>
</td></tr>
</table>
<h2 is-upgraded>iOS</h2>
<table>
<tr></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-ios-1" src="img/92031a5136dd4caf.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-ios-2" src="img/620f5a520c4b09e1.png"></p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img alt="auth-ios-3" src="img/7370305f5cdff3f4.png"></p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="Главный экран" duration="10">
        

      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
